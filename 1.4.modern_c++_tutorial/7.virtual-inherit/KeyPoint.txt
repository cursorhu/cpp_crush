1.虚函数重载
传统 C++中，容易发生意外重载虚函数的事情。例如：

    class Base{
        public:
        virtual void foo();
    };
    class SubClass:Base{
        void foo();
    };

SubClass::foo 可能并不是程序员有意重载虚函数，只是恰好加入了一个具有相同名字的函数。
另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并变成一个普通的类方法，运行时动态绑定都不再支持，
但代码中可能还有基类引用调用子函数，这将造成灾难性的后果。

C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生:
    a. 当子类重载虚函数时，使用 override 关键字，显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译
    b. final 是显式的禁止类和虚函数被继承、重载

2.显式控制构造函数
传统C++ 如果程序员没有定义，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数
如果需要禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 private。 尝试使用这些未定义的函数将导致编译或链接错误
并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数

C++11 提供了允许显式的声明采用或拒绝编译器自带的函数：

classMagic{
    public:
    Magic()=default;// 显式声明使用编译器生成的构造
    Magic& operator=(constMagic&)=delete;// 显式声明拒绝编译器生成构造
    Magic(int magic_number);
}


3.枚举类
传统 C++中，枚举类型会被视作整数，可能两种完全不同的枚举类型可以进行直接的比较。
C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：

    enum class new_enum: unsigned int{
        value1,
        value2,
        value3 =100,
        value4 =100
    };

这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，
同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。
但相同枚举值之间如果指定的值相同，那么可以进行比较：

    if(new_enum::value3 == new_enum::value4){
        std::cout <<"new_enum::value3 == new_enum::value4"<< std::endl;
    }