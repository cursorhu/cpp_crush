右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。
其解决了 C++ 中大量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能

1. 什么是左值，右值：
左值(lvalue)，赋值符号左边的值。
右值(rvalue)，赋值符号右边的值。

lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，
而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）
有名称的、可以获取到存储地址的表达式即为左值；反之则是右值

2.左值引用
C++ 98 的引用就是左值引用：既然左值可以用 & 获取到存储地址，就可以创建其引用
C++ 98 的引用不能创建右值的引用，直白的说，不能取到地址的数据不能创建其引用
不过可以支持常量左值引用

    int num = 10; //num是左值，可取到其地址
    int & b = num; //正确，左值引用
    int & c = 10; //错误, 右值引用不支持
    const int &c = 10; //常量左值引用

2.右值引用

C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示
右值引用还可以对右值进行修改：

    int && a = 10;
    a = 100;


3.移动构造

传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式
由于没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间

以下示例将 temp 拷贝到 v 后再销毁 temp, 如果vector<int>够大，耗费大量资源

    std::vector<int> foo() {
        std::vector<int> temp = {1, 2, 3, 4};
        return temp;
    }
    std::vector<int> v = foo();

C++11 提供 std::move 使一个左值变成右值，该右值在被赋值给其他值时，是直接 移动 到其他值，而不是 拷贝+销毁
见示例代码 move.cc


4.完美转发
完美转发：函数模板可以将自己的参数 “完美” 地转发给内部调用的其它函数。
所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。

要理解完美转发，先看 C++98 的非完美转发：
    template<typename T>
    void function(T t) {
        otherdef(t);
    }

function() 函数模板并没有实现完美转发。
一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；
另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于otherdef()函数内部的参数 t 来说，总可以获取它的存储地址，因此它永远都是左值。

在 C++11 标准中实现完美转发：
    template <typename T>
    void function(T&& t) {
        otherdef(t);
    }

关键点是：
C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。
但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定。既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）

该模板函数在调用时，既能满足右值，又能满足左值
    int n = 10;
    int & num = n;
    function(num); // T 为 int&
    int && num2 = 11;
    function(num2); // T 为 int &&

还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。
那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？
C++11 标准还引入模板函数 forword<T>()，使形参保留其左右值属性
详见示例代码 forward.cc

std::move 单纯的将左值转化为右值，
std::forward 也只是单纯的将参数做了一个类型的转换，从效果上，std::forward<T>(v) 和 static_cast<T&&>(v) 是完全一样的。