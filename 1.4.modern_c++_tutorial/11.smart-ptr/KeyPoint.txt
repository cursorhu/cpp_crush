
1. 指针引起的内存资源管理的常见问题：
有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；
有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；
没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。

2.内存管理的两种思路
垃圾自动回收：编程语言层面提供的，已某种机制定期释放那些不再使用(没有任何指针指向)的内存空间
优点：不需要程序员手动释放。
缺点：垃圾回收的实现通常要 “ stop the world ”, 会短暂中断程序的正常执行。
典型语言： Java、Python、Golang

半自动机制：编程语言层面只提供辅助程序员正确回收内存的机制，内存回收的时机是程序员控制
优点：内存用完即释放
缺点：需要程序员充分理解语言机制
典型语言：C++

3. C++ 的智能指针

(1) new/delete 方式的内存管理：
    C++ 用 new 创建一个对象，返回对象的指针；对象使用完毕后，delete 该对象的指针，该对象的内存空间才被释放
    手动方式容易引起前面说的三种内存管理问题，因为完全要程序员处理

(2) C++98/03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收
    将 new 出来的对象地址赋值给智能指针；在对象析构时，智能指针保证对象的内存空间自动释放
    参考示例代码：auto_ptr.cc 

    注意：auto_ptr是个半成品有缺陷，不建议使用，使用C++11 智能指针
    1）不要使用auto_ptr对象保存指向静态分配对象的指针，否则，当auto_ptr对象本身被撤销的时候，它将试图删除指向非动态分配对象的指针，导致未定义的行为。
    2）永远不要使用两个 auto_ptrs 对象指向同一对象，导致这个错误的一种明显方式是，使用同一指针来初始化或者 reset 两个不同的 auto_ptr对象。另一种导致这个错误的微妙方式可能是，使用一个 auto_ptr 对象的 get 函数的结果来初始化或者 reset另一个 auto_ptr 对象。
    3）不要使用 auto_ptr 对象保存指向动态分配数组的指针。当auto_ptr 对象被删除的时候，它只释放一个对象—它使用普通delete 操作符，而不用数组的 delete [] 操作符。

(3) C++11 标准废弃了 auto_ptr，增添了 unique_ptr、shared_ptr、weak_ptr 这 3 个智能指针来实现堆内存的自动回收

    C++11 智能指针的实现原理: RAII + 引用计数
    在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，即 RAII（资源获取即初始化技术) 思想

    对于动态分配的对象，进行引用计数，
    每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 
    每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存
    其实现类似于 c++_primer_4th/ 6.4smart_ptr

    shared_ptr:
    std::shared_ptr 是一种多个指针能共享对象的智能指针，使用 “引用计数” ，记录有多少个 shared_ptr 共同指向一个对象
    当引用计数变为零的时候就会将对象自动删除, 替代显示的调用 delete 对象
    初始化和赋值：
        auto pointer = std::make_shared<int>(10); //使用make_shared而不是new
        auto pointer2 = pointer; // 引用计数+1

    unique_ptr:    
    std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象
    unique_ptr 虽然不可复制，但是可以移动：利用 std::move 将其转移给其他的 unique_ptr

    初始化和赋值：
        std::unique_ptr<int> pointer = std::make_unique<int>(10); // make_unique 从 C++14 引入
        std::unique_ptr<int> pointer2 = pointer; // 非法

    weak_ptr:
    weak_ptr用于解决 “引用计数” 模型循环依赖问题
    C++11 标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针只能和 shared_ptr 类型指针搭配使用。
    weak_ptr 必须从一个share_ptr或者另一个weak_ptr转换而来，不能使用 new 对象进行构造
    weak_ptr 指向 shared_ptr 指针指向的对象的内存，却并不拥有该内存。因此 weak_ptr 类型指针并不会影响所指堆内存空间的引用计数：
    当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；
    当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。

    借助 weak_ptr 类型指针，可以获取 shared_ptr 指针的计数情况，避免 shared_ptr 循环引用情况下内存泄漏问题
    参考weak_ptr_intro.cc 和 weak_ptr.cc

    